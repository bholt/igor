<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Igor by bholt</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Igor</h1>
        <p>The ideal lab assistant, not just for mad scientists.</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/bholt/igor" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/bholt/igor/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/bholt/igor/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h1>Igor</h1>

<hr><h2>Not just for mad scientists.</h2>

<p>Igor is the ideal lab assistant for any grad student running a countable but nearly infinite number of experiments. It will carry out your orders with terrifying exactitude and collect results.</p>

<p>Igor is an "Interactive Gatherer Of Results" (I.G.O.R.), that is, it is designed to help run experiments, especially parameter sweeps, and gather the results for later analysis and visualization.</p>

<p>What began as a script to enumerate and run all possible combinations of multidimensional variable sweeps has become a system that interfaces with the Slurm job manager, is configured with a simple DSL, and has an interactive Pry shell for watching the progress of experiments, reviewing results, and spawning new experiments.</p>

<h2>Installation</h2>

<p>Make sure you have Ruby 1.9.3 at least, with RubyGems installed.</p>

<p>Then build and install the gem:</p>

<div class="highlight"><pre>gem build igor.gemspec
gem install igor-<span class="o">{</span>version<span class="o">}</span>.gem
</pre></div>

<h2>Examples</h2>

<p>The file <code>examples/sample.rb</code> contains a toy run script that demonstrates a number of features of Igor scripts. The <code>examples</code> directory also contains more realistic scripts used in <a href="http://sampa.cs.washington.edu/grappa">Grappa</a>. In particular, they contain more useful output parsers.</p>

<h2>How-to</h2>

<h3>Writing config/run scripts</h3>

<p>Igor scripts are defined using an Igor DSL block:</p>

<div class="highlight"><pre><span class="nb">require</span> <span class="s1">'igor'</span>
<span class="no">Igor</span> <span class="k">do</span> <span class="c1"># begin DSL block</span>
  <span class="n">database</span> <span class="s1">'sample_igor.db'</span><span class="p">,</span> <span class="ss">:test</span>
  <span class="n">command</span> <span class="s2">"srun echo %{a} %{b}"</span>
  <span class="n">parser</span> <span class="p">{</span><span class="o">|</span><span class="n">cmdout</span><span class="o">|</span>
    <span class="sr">/(?&lt;ao&gt;\d+)\s+(?&lt;bo&gt;\d+)\s+(?&lt;co&gt;\w+)/</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">cmdout</span><span class="p">)</span><span class="o">.</span><span class="n">dictionize</span>
  <span class="p">}</span>
  <span class="n">params</span> <span class="p">{</span>
    <span class="n">nnode</span> <span class="mi">2</span><span class="p">;</span> <span class="n">ppn</span> <span class="mi">2</span>
    <span class="n">a</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
    <span class="n">b</span> <span class="s1">'hello'</span><span class="p">,</span> <span class="s1">'goodbye'</span>
  <span class="p">}</span>
  <span class="n">run</span> <span class="p">{</span> <span class="n">tag</span> <span class="s1">'base experiment'</span> <span class="p">}</span>
  <span class="n">interact</span>
<span class="k">end</span>
</pre></div>

<p>The available DSL configuration commands are:</p>

<table>
<tr>
<th>Command</th>
<th>Alias</th>
<th>Description</th>
</tr>
<tr>
<td><code>database(path, table)</code></td>
<td><code>db</code></td>
<td>overrides any other database configs to use the specified one</td>
</tr>
<tr>
<td><code>command(string)</code></td>
<td><code>cmd</code></td>
<td>
<code>string</code> can contain substitutions like "%{name}" where "name" is a key in the params hash</td>
</tr>
<tr>
<td><code>interact</code></td>
<td></td>
<td>enter Pry prompt, should probably be the last item (if you want an interactive session)</td>
</tr>
<tr>
<td><code>parser(&amp;blk)</code></td>
<td></td>
<td>the block/lambda receives a string containing all the output from the job, and should parse out important results and return a hash, or list of hashes, representing records to be inserted in the database (these get merged with the params and job information in the database)</td>
</tr>
<tr>
<td><code>expect(*fields)</code></td>
<td></td>
<td>(takes a variable number of arguments) fields that, if not present in the output, mean the result was invalid (e.g. <code>:nnode</code>). Jobs considered invalid are not inserted in the "results" table, but still appear in the "jobs" table (see below for how to query these tables)</td>
</tr>
<tr>
<td><code>sbatch_flags</code></td>
<td></td>
<td>(getter/setter) list of string arguments to pass to sbatch (e.g. <code>sbatch_flags &lt;&lt; '--time=15:00'</code>)</td>
</tr>
<tr>
<td><code>params(&amp;blk)</code></td>
<td></td>
<td>add to the global parameters (if the same name is used, it overrides previous values), <code>params</code> should be treated in an imperative style, so any calls to <code>run</code> after it use the values it set (uses an ad-hoc DSL that lets you specify arbitrary parameters easily, see more detailed description below)</td>
</tr>
<tr>
<td><code>run(&amp;blk)</code></td>
<td></td>
<td>runs a set of experiments based on the global params combined with params specified in this DSL block. These parameters or overrides only apply within that run. Note: this skips any experiments that already appear in the results table with identical parameters.</td>
</tr>
<tr>
<td><code>run_forced(&amp;blk)</code></td>
<td></td>
<td>Run the specified experiments even if they already appear in the results table.</td>
</tr>
</table><h4>Specifying experiments</h4>

<p>Igor's experiment-running is based around running all possible combinations of various parameter sweeps. That is, often when running experiments, one wants to vary, say, the number of cluster nodes, as well as the size of the problem. In order to get all of the possible combinations, you take the cartesian product of the two sets of parameter variations.</p>

<p>Because specifying all of these parameters and their combinations is so common, Igor has special syntax to make it as easy as possible to represent them. Similar to how "Igor do...end" blocks have a DSL, parameter commands (<code>params</code>, <code>run</code>, and <code>run_forced</code>), accept a special DSL syntax:</p>

<div class="highlight"><pre><span class="n">params</span> <span class="p">{</span>
  <span class="n">constant</span> <span class="mi">16</span>
  <span class="n">nnode</span>    <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span>
  <span class="n">scale</span>    <span class="mi">26</span>
<span class="p">}</span>
<span class="c1">#=&gt; @params.merge!({:constant=&gt;[16], :nnode=&gt;[2, 4], :scale=&gt;[26]})</span>
<span class="n">run</span> <span class="p">{</span> <span class="n">tag</span> <span class="s1">'foo'</span> <span class="p">}</span>
<span class="c1"># resulting parameter hash =&gt; {:constant=&gt;[16], :nnode=&gt;[2, 4], :scale=&gt;[26], :tag=&gt;["foo"]}</span>
<span class="c1"># runs experiments:</span>
<span class="c1">#   { constant:16, nnode:2, scale:26, tag:"foo" }</span>
<span class="c1">#   { constant:16, nnode:4, scale:26, tag:"foo" }</span>
<span class="c1"># (@params == {:constant=&gt;[16], :nnode=&gt;[2, 4], :scale=&gt;[26]} still)</span>
</pre></div>

<h3>Interactive commands</h3>

<p>Igor leverages the <a href="http://pryrepl.org/">Pry</a> REPL to do its interactive prompt. When <code>interact</code> is called from a script, it will leave you at a prompt like this:</p>

<div class="highlight"><pre><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="n">pry</span><span class="p">(</span><span class="no">Igor</span><span class="p">)</span><span class="o">&gt;</span> 
</pre></div>

<p>This indicates that we're "inside" Igor right now, so anything that could be called from within an Igor block in the script can be called here (for example, we can issue new experiments with <code>run</code>).</p>

<p>There are also some additional commands that don't make sense in the configure scripts:</p>

<ul>
<li>
<p><code>status</code> (alias: <code>st</code>): Print the status of all jobs. For example:</p>

<div class="highlight"><pre><span class="o">[</span> <span class="mi">0</span><span class="o">]</span> <span class="mi">2369991</span><span class="p">:</span> <span class="no">JOB_RUNNING</span> <span class="n">on</span> <span class="n">node</span><span class="o">[</span><span class="mo">015</span><span class="mi">8</span><span class="p">,</span><span class="mo">0160</span><span class="o">-</span><span class="mo">0170</span><span class="p">,</span><span class="mo">0172</span><span class="o">-</span><span class="mo">01</span><span class="mi">97</span><span class="p">,</span><span class="mo">01</span><span class="mi">99</span><span class="p">,</span><span class="mo">0202</span><span class="o">-</span><span class="mo">0204</span><span class="p">,</span><span class="mo">03</span><span class="mi">97</span><span class="o">-</span><span class="mo">0404</span><span class="p">,</span><span class="mo">0406</span><span class="p">,</span><span class="mo">0476</span><span class="o">-</span><span class="mo">04</span><span class="mi">88</span><span class="o">]</span><span class="p">,</span> <span class="ss">time</span><span class="p">:</span> <span class="mo">01</span><span class="p">:</span><span class="mi">49</span><span class="p">:</span><span class="mi">16</span>  
<span class="o">[</span> <span class="mi">1</span><span class="o">]</span> <span class="mi">2370012</span><span class="p">:</span> <span class="no">JOB_RUNNING</span> <span class="n">on</span> <span class="n">node</span><span class="o">[</span><span class="mo">0423</span><span class="p">,</span><span class="mo">0425</span><span class="o">-</span><span class="mo">043</span><span class="mi">9</span><span class="o">]</span><span class="p">,</span> <span class="ss">time</span><span class="p">:</span> <span class="mo">00</span><span class="p">:</span><span class="mi">49</span><span class="p">:</span><span class="mi">51</span>
<span class="o">[</span> <span class="mi">2</span><span class="o">]</span> <span class="mi">2370013</span><span class="p">:</span> <span class="no">JOB_RUNNING</span> <span class="n">on</span> <span class="n">node</span><span class="o">[</span><span class="mo">0440</span><span class="p">,</span><span class="mo">0445</span><span class="o">-</span><span class="mo">045</span><span class="mi">9</span><span class="o">]</span><span class="p">,</span> <span class="ss">time</span><span class="p">:</span> <span class="mo">00</span><span class="p">:</span><span class="mi">49</span><span class="p">:</span><span class="mi">51</span>
<span class="o">[</span> <span class="mi">3</span><span class="o">]</span> <span class="mi">2370015</span><span class="p">:</span> <span class="no">JOB_RUNNING</span> <span class="n">on</span> <span class="n">node</span><span class="o">[</span><span class="mo">0407</span><span class="o">-</span><span class="mo">0422</span><span class="p">,</span><span class="mo">0460</span><span class="o">-</span><span class="mo">0475</span><span class="o">]</span><span class="p">,</span> <span class="ss">time</span><span class="p">:</span> <span class="mo">00</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">48</span>
     <span class="p">{</span> <span class="ss">nnode</span><span class="p">:</span><span class="mi">32</span><span class="p">,</span> <span class="ss">ppn</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="ss">scale</span><span class="p">:</span><span class="mi">28</span> <span class="p">}</span>
<span class="o">[</span> <span class="mi">4</span><span class="o">]</span> <span class="mi">2370016</span><span class="p">:</span> <span class="no">JOB_PENDING</span> <span class="n">on</span> <span class="p">,</span> <span class="ss">time</span><span class="p">:</span> <span class="mi">21</span><span class="p">:</span><span class="mi">49</span><span class="p">:</span><span class="mi">16</span>
     <span class="p">{</span> <span class="ss">nnode</span><span class="p">:</span><span class="mi">32</span><span class="p">,</span> <span class="ss">ppn</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="ss">scale</span><span class="p">:</span><span class="mi">28</span> <span class="p">}</span>
<span class="o">[</span> <span class="mi">5</span><span class="o">]</span> <span class="mi">2370031</span><span class="p">:</span> <span class="no">JOB_PENDING</span> <span class="n">on</span> <span class="p">,</span> <span class="ss">time</span><span class="p">:</span> <span class="mo">02</span><span class="p">:</span><span class="mi">16</span><span class="p">:</span><span class="mo">00</span>
     <span class="p">{</span> <span class="ss">nnode</span><span class="p">:</span><span class="mi">16</span><span class="p">,</span> <span class="ss">ppn</span><span class="p">:</span><span class="mi">16</span><span class="p">,</span> <span class="ss">scale</span><span class="p">:</span><span class="mi">28</span> <span class="p">}</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
</pre></div>

<p>In square brackets [] is a "job alias" that you can use in a few commands to specify a running job. Notice some jobs have a param hash beneath them. These are jobs that were submitted by this Igor session, and the hash displays just the "distinguishing" parameters (ones that vary).</p>
</li>
<li><p><code>attach([job_alias])</code> (aliases: <code>a</code>, <code>at</code>): Attach to a running or pending job (read-only). Detach with <code>ctrl-c</code>. Defaults to the last job.</p></li>
<li><p><code>view([path|job_alias])</code>: Cat the output file for a job. You can specify either the output path directly or with a job alias, which you can find by running <code>status</code>. Defaults to the last job.</p></li>
<li><p><code>tail([path|job_alias])</code>: Just like <code>view</code> but tails the file, in case it's still growing. Mostly unnecessary if the <code>attach</code> command works. Defaults to the last job.</p></li>
<li><p><code>kill([job_alias])</code>: Kill (using <code>scancel</code>) job given a job_alias. Defaults to the last job.</p></li>
<li>
<p><code>gdb(node,pid)</code>: Convenience command to create the command to ssh to a node and attach to a running process. Pry interprets commands beginning with "." as shell commands, and allows Ruby-style string "interpolation", so to use this, you can call: </p>

<div class="highlight"><pre><span class="n">pry</span><span class="p">(</span><span class="no">Igor</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">.</span><span class="c1">#{gdb 'n01', '1234'}</span>
</pre></div>
</li>
<li><p><code>results(&amp;blk)</code>, <code>jobs(&amp;blk)</code>, <code>recent_jobs(&amp;blk)</code>, <code>sql(string)</code>: Query the database in a number of ways. See below.</p></li>
</ul><h4>Querying results</h4>

<p>The query commands use the Sequel DSL inside the block to query the table specified by <code>database()</code> in the Igor configuration. The block should return a <code>Sequel::Dataset</code>. Supports a couple different calling styles:</p>

<ul>
<li>
<code>results{ select(:id,:nnode,:ppn,:max_teps) }</code>: works as if "inside" the dataset, calling methods on <code>self</code> (could also say <code>self.select()</code>...)</li>
<li>
<code>results{|d| d.where(:scale =&gt; 16)}</code>: with an explicit dataset argument</li>
</ul><p>The call to <code>results</code> returns a Sequel::Model instance. The fields of a Model can't be modified after creation, so the block passed to results is used to create the dataset before the Model is created. Typically, the Model object is just used to display all the queried records by calling  <code>all</code> on it: <code>results{select :id,:max_teps}.all</code>.</p>

<p>The other query commands <code>jobs</code> and <code>recent_jobs</code> query from the <code>jobs</code> table. The <code>jobs</code> table is shared among all Igor scripts. Useful fields in the table:</p>

<ul>
<li>
<code>:results</code>: string containing the results hash that was parsed</li>
<li>
<code>:error</code>: When jobs start running, they insert a placeholder record with the <code>:error</code> field set to "x". If the job crashes and doesn't get a chance to clean up properly, this record will still be there. If the job fails more cleanly, then this record will be modified to reflect the actual error message (and set <code>:results</code>).</li>
<li>
<code>:started_at</code>: time the job started running</li>
<li>
<code>:run_at</code>: time the Igor script was started, less useful for interactively submitted jobs</li>
<li>
<code>:outfile</code>: path to the job output log, can be passed to the <code>view</code> command.<br>
</li>
</ul><p>You can also query using SQL directly rather than using the Sequel Ruby DSL. The command, <code>sql(s)</code>, takes a string, and returns a Sequel::Model just like the other query functions (i.e. you'll want to call something like <code>all</code> on it to see the results). For example:</p>

<div class="highlight"><pre><span class="n">pry</span><span class="p">(</span><span class="no">Igor</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">sql</span><span class="p">(</span><span class="s2">"select * from jobs"</span><span class="p">)</span><span class="o">.</span><span class="n">all</span>
<span class="c1"># or multiline:</span>
<span class="n">pry</span><span class="p">(</span><span class="no">Igor</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">sql</span><span class="p">(</span><span class="sx">%q{</span>
<span class="sx">  select id, nnode, ppn, results</span>
<span class="sx">  from jobs</span>
<span class="sx">  where outfile like "%CombBLAS%"</span>
<span class="sx">}</span><span class="p">)</span><span class="o">.</span><span class="n">all</span>
</pre></div>

<p>It may be worth noting that the query isn't actually executed in any of these until you call something on the Model object, such as <code>.all</code>, or <code>.first</code>, or <code>.count</code>.</p>

<h5>Example queries</h5>

<p>Show the top 5 BFS results of scale 25:</p>

<div class="highlight"><pre><span class="n">pry</span><span class="p">(</span><span class="no">Igor</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">:scale</span><span class="o">=&gt;</span><span class="mi">25</span><span class="p">)</span>
        <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span><span class="ss">:mpibfs</span><span class="p">,</span><span class="ss">:nnode</span><span class="p">,</span><span class="ss">:ppn</span><span class="p">,</span><span class="ss">:max_teps</span><span class="p">)</span>
        <span class="o">.</span><span class="n">reverse_order</span><span class="p">(</span><span class="ss">:max_teps</span><span class="p">)</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">}</span><span class="o">.</span><span class="n">all</span>
</pre></div>

<p>Breaking it down: <code>results</code> takes a block which can be run as if by the <code>Sequel::Dataset</code> object, allowing the clean DSL-like syntax (<code>select</code> has <code>@db[@dbtable]</code> as its implicit <code>self</code>). Then we select some fields, sort the results by the "max_teps" field, and filter just ones where <code>:scale</code> is 25. More documentation on the chaining query methods can be found <a href="http://sequel.rubyforge.org/rdoc/files/doc/querying_rdoc.html">here</a>.</p>

<p>Because of the way Sequel's <code>Model</code>s work, once they're created, they have a fixed format. This block syntax lets us get around it by setting up the query before the Model object is created. Then we just call <code>all</code> on the model, which displays all queried results as a nicely formatted table.</p>

<h4>Additional reading</h4>

<p>General useful documentation on the Ruby Sequel DSL <a href="http://sequel.rubyforge.org/rdoc/files/doc/sql_rdoc.html">sequel/sql.rdoc</a>.</p>
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/bholt">bholt</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="http://twitter.com/#!/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>